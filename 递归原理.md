# 递归原理

demo recursive.js

函数调用栈的聚合过程

非常类似 reduce

递归, 就是把 while 循环,封装成函数调用

递归迭代, 有其特性 栈, 闭包

# 如何理解

尝试把循环改写成函数调用

理解递归, 本质是就是循环, 迭代指针.

理解递归,这种遍历方式的特性, 函数调用栈, 闭包.

理解: 递归中, 归的过程.
通过 reduce 理解 聚合过程, 最后返回一个结果的这么个过程.

树的遍历

全排列, 爬楼梯, 99 乘法表

尝试脑海 想象树的 遍历/下钻过程

最后记忆 公式

# 递归函数四个要点: 边界, 数据, 迭代, 聚合

定义边界,防止死循环
数据初始化或处理
迭代, 偏移指针
聚合数据

```js
//======================= 递归结果
// 初始 | 初+处理? > 迭 | 归 (初+处理?)+归
// 初始 | 初+处理? > 迭 | 归 (初+处理?)+归
// 初始 | 初+处理? > 迭 | 归 (初+处理?)+归
// 0  迭代边界 => 递归边界

function _while(data) {
  // 1. 边界: 防止死循环.
  // 如果迭代两指针-维度,那么应该有两边界
  // 返回: 最小问提解
  // 剪枝: 提前返回.
  // 跳过: 迭代下一个指针.
  if (data.length == 0) return 0;

  // 2. 递: 递进过程, 指针展开过程, 捕获过程
  // 定义/确认栈数据, 初始化数据,或其他处理

  let curStackAcc = data[0].length;

  // 3.确定展开方向
  // 确认维度: 一个指针一个维度

  // 4. 迭代: 偏移指针,
  let bottom_stack_acc = _while(data.slice(1)); // 展开方向, 可能有多个分支.

  // 5. 归: 指针回归过程,冒泡过程, 聚合数据, 或其他处理
  curStackAcc += bottom_stack_acc;

  return curStackAcc;
}

// 计算 字符串长度和
console.log(_while(["-", "--", "---"])); // 6

// 递归原理: 递-递进展开,归-回归聚合

// 四部曲:
// 基本边界
// 定义数据
// 确认方向和维度
// 迭代指针
// 回归聚合

// 函数调用栈的聚合过程, 将指针展开

// 非常类似 reduce

// 递归, 就像把 while 循环,封装成函数调用

// 递归迭代, 有其特性 栈, 闭包

// 任何解决方案, 都是重复, 可迭代.

// 任何算法迭代都可相互转化

// for, do/while 和 递归, 递推 之间能转化.
```
